name: Build Buildah

on:
  # Manual trigger with version input
  workflow_dispatch:
    inputs:
      version:
        description: 'Buildah version to build (leave empty for latest from GitHub)'
        required: false
        type: string
        default: ''
      architecture:
        description: 'Target architecture'
        required: false
        type: choice
        options:
          - amd64
          - arm64
          - both
        default: both
      variant:
        description: 'Build variant (standalone/default/full or all)'
        required: false
        type: choice
        options:
          - standalone
          - default
          - full
          - all
        default: all

  # Called by check-releases workflow
  workflow_call:
    inputs:
      version:
        description: 'Buildah version to build'
        required: true
        type: string

# Ensure only one build runs at a time per version
concurrency:
  group: build-buildah-${{ inputs.version }}
  cancel-in-progress: false

permissions:
  contents: write
  id-token: write  # Required for cosign OIDC

jobs:
  validate:
    name: Validate version
    runs-on: ubuntu-latest
    steps:
      - name: Validate semver pattern
        env:
          VERSION: ${{ inputs.version }}
        run: |
          # Semver pattern: v1.2.3 or v1.2 or 1.2.3 or 1.2
          SEMVER_PATTERN='^v?[0-9]+\.[0-9]+(\.[0-9]+)?$'

          # Skip validation if version is empty (will use latest)
          if [[ -z "$VERSION" ]]; then
            echo "‚úì No version specified, will use latest from GitHub"
            exit 0
          fi

          if [[ ! "$VERSION" =~ $SEMVER_PATTERN ]]; then
            echo "Error: Invalid version format '$VERSION'"
            echo "Expected format: v1.2.3 or v1.2 or 1.2.3 or 1.2"
            exit 1
          fi

          echo "‚úì Version '$VERSION' is valid"

  build:
    name: Build buildah-${{ matrix.libc }}-${{ matrix.variant }}-${{ matrix.arch }}
    needs: validate
    runs-on: ${{ matrix.runner }}
    outputs:
      version: ${{ steps.version.outputs.version }}
    strategy:
      matrix:
        arch: [amd64, arm64]
        variant: [standalone, default, full]
        libc: [static, glibc]
        include:
          - arch: amd64
            runner: ubuntu-24.04
          - arch: arm64
            runner: ubuntu-24.04-arm
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Install podman (pigfoot-static-default)
        run: |
          sudo apt-get update && sudo apt-get install -y passt jq zstd

          REPO="pigfoot/static-rootless-container-tools"
          TAG=$(curl -s "https://api.github.com/repos/${REPO}/releases" | \
            jq -r '[.[] | select(.tag_name | startswith("podman-"))][0].tag_name')

          # Skip if no release exists (first-time bootstrap build)
          if [[ -z "$TAG" || "$TAG" == "null" ]]; then
            echo "‚ö† No podman release found - this is a bootstrap build"
            echo "Will use system docker for container runtime (via run-build.sh fallback)"
            exit 0
          fi

          echo "Installing podman from release: $TAG"
          cd /tmp
          curl -fsSL "https://github.com/${REPO}/releases/download/${TAG}/podman-${TAG#podman-}-linux-${{ matrix.arch }}-static.tar.zst" | zstd -d | tar xf -
          cd podman-${TAG#podman-}

          sudo cp -f usr/local/bin/* /usr/bin/
          sudo cp -a usr/local/lib/* /usr/lib/ 2>/dev/null || true
          sudo cp -a usr/local/libexec/* /usr/libexec/ 2>/dev/null || true
          sudo mkdir -p /etc/containers && sudo cp -a etc/containers/* /etc/containers/

          echo "‚úì Installed: $(podman --version)"

      - name: Detect toolchain versions
        id: detect-versions
        run: |
          # Detect latest LLVM version
          LLVM_VERSION=$(curl -fsSL https://api.github.com/repos/llvm/llvm-project/releases/latest | jq -r '.tag_name' | sed 's/llvmorg-//')
          echo "llvm-version=${LLVM_VERSION}" >> $GITHUB_OUTPUT

          # Detect latest Go version
          GO_VERSION=$(curl -fsSL https://go.dev/VERSION?m=text | head -1 | sed 's/go//')
          echo "go-version=${GO_VERSION}" >> $GITHUB_OUTPUT

          echo "Detected LLVM: ${LLVM_VERSION}, Go: ${GO_VERSION}"

      - name: Cache toolchains
        id: cache-toolchains
        uses: actions/cache@v5
        with:
          path: |
            ~/.cache/static-build-tools/llvm-${{ matrix.arch }}
            ~/.cache/static-build-tools/go-${{ matrix.arch }}
          key: toolchain-${{ matrix.arch }}-llvm${{ steps.detect-versions.outputs.llvm-version }}-go${{ steps.detect-versions.outputs.go-version }}
          restore-keys: |
            toolchain-${{ matrix.arch }}-

      - name: Download LLVM (cache miss)
        if: steps.cache-toolchains.outputs.cache-hit != 'true'
        env:
          LLVM_VERSION: ${{ steps.detect-versions.outputs.llvm-version }}
        run: |
          CACHE_DIR="$HOME/.cache/static-build-tools"
          mkdir -p "$CACHE_DIR/llvm-${{ matrix.arch }}"

          # Detect LLVM arch
          if [[ "${{ matrix.arch }}" == "amd64" ]]; then LLVM_ARCH="X64"; else LLVM_ARCH="ARM64"; fi

          LLVM_TAG="llvmorg-${LLVM_VERSION}"
          LLVM_URL="https://github.com/llvm/llvm-project/releases/download/${LLVM_TAG}/LLVM-${LLVM_VERSION}-Linux-${LLVM_ARCH}.tar.xz"
          echo "Downloading LLVM ${LLVM_VERSION}..."

          curl -fsSL "$LLVM_URL" -o /tmp/llvm.tar.xz
          tar -xf /tmp/llvm.tar.xz -C "$CACHE_DIR/llvm-${{ matrix.arch }}" --strip-components=1
          rm /tmp/llvm.tar.xz
          echo "${LLVM_VERSION}" > "$CACHE_DIR/llvm-${{ matrix.arch }}/.version"
          echo "LLVM ${LLVM_VERSION} cached at: $CACHE_DIR/llvm-${{ matrix.arch }}"

      - name: Download Go (cache miss)
        if: steps.cache-toolchains.outputs.cache-hit != 'true'
        env:
          GO_VERSION: ${{ steps.detect-versions.outputs.go-version }}
        run: |
          CACHE_DIR="$HOME/.cache/static-build-tools"
          mkdir -p "$CACHE_DIR/go-${{ matrix.arch }}"

          echo "Downloading Go ${GO_VERSION}..."
          curl -fsSL "https://go.dev/dl/go${GO_VERSION}.linux-${{ matrix.arch }}.tar.gz" -o /tmp/go.tar.gz
          tar -xzf /tmp/go.tar.gz -C "$CACHE_DIR/go-${{ matrix.arch }}" --strip-components=1
          rm /tmp/go.tar.gz
          echo "${GO_VERSION}" > "$CACHE_DIR/go-${{ matrix.arch }}/.version"
          echo "Go ${GO_VERSION} cached at: $CACHE_DIR/go-${{ matrix.arch }}"

      - name: Pull container image
        run: |
          # Detect container runtime (podman or docker)
          if command -v podman >/dev/null 2>&1; then
            CONTAINER_RUNTIME="podman"
          elif command -v docker >/dev/null 2>&1; then
            CONTAINER_RUNTIME="docker"
            echo "‚ö† Using docker as container runtime (bootstrap build)"
          else
            echo "Error: Neither podman nor docker is installed"
            exit 1
          fi

          $CONTAINER_RUNTIME pull docker.io/ubuntu:latest

      - name: Create build directory
        run: mkdir -p build

      - name: Run build and package in container
        env:
          VERSION: ${{ needs.build.outputs.version }}
          TOOL: buildah
          ARCH: ${{ matrix.arch }}
          VARIANT: ${{ matrix.variant }}
          LIBC: ${{ matrix.libc }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Record build start time (NFR-005: build duration < 30 minutes)
          BUILD_START=$(date +%s)
          echo "Build started at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"

          CACHE_DIR="$HOME/.cache/static-build-tools"
          CACHE_MOUNTS=""
          USE_CACHED_LLVM=0
          USE_CACHED_GO=0

          if [[ -x "$CACHE_DIR/llvm-$ARCH/bin/clang" ]]; then
            echo "Using cached LLVM"
            CACHE_MOUNTS="$CACHE_MOUNTS -v $CACHE_DIR/llvm-$ARCH:/usr/local/llvm:ro,z"
            USE_CACHED_LLVM=1
          fi

          if [[ -x "$CACHE_DIR/go-$ARCH/bin/go" ]]; then
            echo "Using cached Go"
            CACHE_MOUNTS="$CACHE_MOUNTS -v $CACHE_DIR/go-$ARCH:/usr/local/go:ro,z"
            USE_CACHED_GO=1
          fi

          # Detect container runtime (podman or docker)
          if command -v podman >/dev/null 2>&1; then
            CONTAINER_RUNTIME="podman"
          elif command -v docker >/dev/null 2>&1; then
            CONTAINER_RUNTIME="docker"
            echo "‚ö† Using docker as container runtime (bootstrap build)"
          else
            echo "Error: Neither podman nor docker is installed"
            exit 1
          fi

          $CONTAINER_RUNTIME run --rm \
            $CACHE_MOUNTS \
            -v ./scripts:/workspace/scripts:ro,z \
            -v ./build:/workspace/build:rw,z \
            -e VERSION=$VERSION \
            -e TOOL=$TOOL \
            -e ARCH=$ARCH \
            -e VARIANT=$VARIANT \
            -e LIBC=$LIBC \
            -e GITHUB_TOKEN=$GITHUB_TOKEN \
            -e USE_CACHED_LLVM=$USE_CACHED_LLVM \
            -e USE_CACHED_GO=$USE_CACHED_GO \
            docker.io/ubuntu:latest \
            bash -c '
              source /workspace/scripts/container/setup-build-env.sh && \
              /workspace/scripts/build-tool.sh '"$TOOL $ARCH $VARIANT $LIBC"' && \
              DETECTED_VERSION=$(cat /workspace/build/.detected-version) && \
              /workspace/scripts/package.sh '"$TOOL $ARCH $LIBC $VARIANT"' "$DETECTED_VERSION" && \
              echo "CLANG_VERSION=$(clang --version | head -n1 | awk '\''{print $3}'\'')" >> /workspace/build/tool-versions.env && \
              echo "GO_VERSION=$(go version | awk '\''{print $3}'\'' | sed '\''s/go//'\'')" >> /workspace/build/tool-versions.env && \
              echo "RUST_VERSION=$(rustc --version | awk '\''{print $2}'\'')" >> /workspace/build/tool-versions.env && \
              echo "CMAKE_VERSION=$(/usr/local/cmake/bin/cmake --version | head -n1 | awk '\''{print $3}'\'')" >> /workspace/build/tool-versions.env && \
              echo "NINJA_VERSION=$(/root/.local/bin/uv tool run ninja --version)" >> /workspace/build/tool-versions.env && \
              echo "PYTHON_VERSION=$(/root/.local/bin/uv run python --version | awk '\''{print $2}'\'')" >> /workspace/build/tool-versions.env && \
              echo "GLIB_VERSION=$(PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:/usr/local/lib64/pkgconfig pkg-config --modversion glib-2.0 2>/dev/null || echo N/A)" >> /workspace/build/tool-versions.env
            '

          # Calculate and validate build duration
          BUILD_END=$(date +%s)
          BUILD_DURATION=$((BUILD_END - BUILD_START))
          BUILD_MINUTES=$((BUILD_DURATION / 60))
          BUILD_SECONDS=$((BUILD_DURATION % 60))

          echo "Build completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Build duration: ${BUILD_MINUTES}m ${BUILD_SECONDS}s"

          # Validate build time < 30 minutes (1800 seconds)
          if [[ $BUILD_DURATION -ge 1800 ]]; then
            echo "‚ùå Build time exceeded 30 minutes limit (NFR-005)"
            echo "Actual: ${BUILD_MINUTES}m ${BUILD_SECONDS}s, Limit: 30m"
            exit 1
          else
            echo "‚úÖ Build time within limit: ${BUILD_MINUTES}m ${BUILD_SECONDS}s < 30m"
          fi

      - name: Verify linking
        env:
          ARCH: ${{ matrix.arch }}
          LIBC: ${{ matrix.libc }}
        run: |
          # Determine install directory based on LIBC variant
          if [[ "$LIBC" == "glibc" ]]; then
            INSTALL_DIR="build/buildah-${ARCH}-glibc/install/bin/"
          else
            INSTALL_DIR="build/buildah-${ARCH}/install/bin/"
          fi

          echo "Checking directory: $INSTALL_DIR"
          ls -la "$INSTALL_DIR" || {
            echo "Error: Directory $INSTALL_DIR not found"
            exit 1
          }

          found_binary=false
          for binary in "$INSTALL_DIR"/*; do
            # Skip if glob didn't match any files (bash returns the pattern itself)
            if [[ ! -f "$binary" ]]; then
              echo "Skipping non-file: $binary"
              continue
            fi

            found_binary=true
            echo "Checking: $binary"
            output=$(ldd "$binary" 2>&1 || true)

            if [[ "$LIBC" == "glibc" ]]; then
              # For glibc variant: allow only glibc dependencies
              if echo "$output" | grep -q "not a dynamic executable\|statically linked"; then
                echo "‚úì $binary is statically linked (even better than glibc-dynamic)"
              elif echo "$output" | grep -E "libc\.so\.6|libm\.so\.6|libresolv\.so\.2|libgcc_s\.so\.1|linux-vdso\.so\.1|ld-linux" | grep -v -E "libstdc\+\+|libcap|libglib" >/dev/null; then
                echo "‚úì $binary uses glibc dynamic linking (only glibc dependencies allowed)"
                # Verify no forbidden libraries
                if echo "$output" | grep -E "libstdc\+\+\.so|libcap\.so|libglib|libsystemd\.so" >/dev/null; then
                  echo "‚úó $binary has forbidden dynamic dependencies:"
                  echo "$output"
                  exit 1
                fi
              else
                echo "‚úó $binary linking verification failed:"
                echo "$output"
                exit 1
              fi
            else
              # For static variant: must be fully static
              if echo "$output" | grep -q "not a dynamic executable\|statically linked"; then
                echo "‚úì $binary is statically linked"
              else
                echo "‚úó $binary is NOT statically linked:"
                echo "$output"
                exit 1
              fi
            fi
          done

          if [[ "$found_binary" == "false" ]]; then
            echo "Error: No binaries found in $INSTALL_DIR"
            exit 1
          fi

      - name: Validate artifact sizes
        env:
          ARCH: ${{ matrix.arch }}
          LIBC: ${{ matrix.libc }}
        run: |
          echo "=== Validating artifact sizes ==="

          # Determine install directory based on LIBC variant
          if [[ "$LIBC" == "glibc" ]]; then
            INSTALL_DIR="build/buildah-${ARCH}-glibc/install/bin/"
          else
            INSTALL_DIR="build/buildah-${ARCH}/install/bin/"
          fi

          # NFR-002: Individual binaries < 50MB (52428800 bytes)
          echo "Checking individual binary sizes (must be < 50MB)..."
          for binary in "$INSTALL_DIR"/*; do
            if [[ ! -f "$binary" ]]; then
              continue
            fi

            size=$(stat -c%s "$binary" 2>/dev/null || stat -f%z "$binary" 2>/dev/null)
            size_mb=$((size / 1048576))

            if [[ $size -ge 52428800 ]]; then
              echo "‚ùå Binary size exceeded 50MB limit (NFR-002)"
              echo "  File: $(basename "$binary")"
              echo "  Size: ${size_mb}MB"
              exit 1
            else
              echo "  ‚úÖ $(basename "$binary"): ${size_mb}MB < 50MB"
            fi
          done

          echo ""
          echo "‚úÖ All artifact sizes within limits"

      - name: Test buildah binary
        env:
          ARCH: ${{ matrix.arch }}
          LIBC: ${{ matrix.libc }}
        run: |
          echo "Testing buildah binary on native ${{ matrix.arch }} runner..."

          # Determine install directory based on LIBC variant
          if [[ "$LIBC" == "glibc" ]]; then
            INSTALL_DIR="build/buildah-${ARCH}-glibc/install/bin/"
          else
            INSTALL_DIR="build/buildah-${ARCH}/install/bin/"
          fi

          "$INSTALL_DIR/buildah" --version
          echo "‚úì buildah binary works correctly"

      - name: Set tarball name
        id: tarball
        env:
          VARIANT: ${{ matrix.variant }}
          ARCH: ${{ matrix.arch }}
          LIBC: ${{ matrix.libc }}
        run: |
          # Read the actual version used by build-tool.sh
          DETECTED_VERSION=$(cat build/.detected-version 2>/dev/null || echo "")
          if [[ -z "$DETECTED_VERSION" ]]; then
            echo "Error: Could not read detected version from build/.detected-version"
            exit 1
          fi

          # Tarball naming matches package.sh: {tool}-{version}-linux-{arch}-{libc}[-{variant}].tar.zst
          if [[ "$VARIANT" == "default" ]]; then
            TARBALL_NAME="buildah-${DETECTED_VERSION}-linux-${ARCH}-${LIBC}.tar.zst"
          else
            TARBALL_NAME="buildah-${DETECTED_VERSION}-linux-${ARCH}-${LIBC}-${VARIANT}.tar.zst"
          fi
          echo "name=$TARBALL_NAME" >> $GITHUB_OUTPUT

      - name: Export version for release job
        id: version
        run: |
          DETECTED_VERSION=$(cat build/.detected-version)
          echo "version=$DETECTED_VERSION" >> $GITHUB_OUTPUT
          echo "Exporting version for release job: $DETECTED_VERSION"

      - name: Upload artifacts
        uses: actions/upload-artifact@v5
        with:
          name: buildah-${{ matrix.libc }}-${{ matrix.variant }}-${{ matrix.arch }}
          path: |
            build/${{ steps.tarball.outputs.name }}
          retention-days: 7

  release:
    name: Create GitHub Release
    needs: build
    if: success()  # Only create release if all matrix builds succeeded
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Download buildah artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: buildah-*
          path: artifacts/

      - name: Consolidate artifacts
        run: |
          mkdir -p release/
          find artifacts/ -type f -name "buildah-*.tar.zst" -exec cp {} release/ \;
          ls -lh release/

      - name: Setup cosign
        uses: sigstore/cosign-installer@v4.0.0

      - name: Generate checksums and sign artifacts
        run: |
          chmod +x scripts/sign-release.sh
          scripts/sign-release.sh release/

      - name: Create Release
        env:
          GH_TOKEN: ${{ github.token }}
          VERSION: ${{ needs.build.outputs.version }}
        run: |
          TAG="buildah-${VERSION}"

          # Load tool versions from build
          if [[ -f build/tool-versions.env ]]; then
            source build/tool-versions.env
          else
            # Fallback versions if file not found
            CLANG_VERSION="21.1.x"
            GO_VERSION="1.25.x"
            RUST_VERSION="1.92.x"
            CMAKE_VERSION="4.2.x"
            NINJA_VERSION="1.13.x"
            PYTHON_VERSION="3.14.x"
            GLIB_VERSION="N/A"
          fi

          # Create release notes
          cat > /tmp/release-notes.md <<NOTES
          Static and glibc-dynamic binaries for buildah built with Clang + mimalloc (containerized build)

          **ARCHITECTURES**
            - linux/amd64
            - linux/arm64

          **LIBC VARIANTS**
            - `*-static.tar.zst`: Fully static (musl), zero runtime dependencies (‚≠ê RECOMMENDED for maximum portability)
            - `*-glibc.tar.zst`: Hybrid static (glibc-dynamic), requires glibc 2.34+ (Ubuntu 22.04+, Debian 12+, RHEL 9+)

          **PACKAGE VARIANTS**
            - `buildah-{version}-linux-{arch}-{libc}.tar.zst`: Default with crun + conmon + configs (‚≠ê RECOMMENDED for most users)
            - `buildah-{version}-linux-{arch}-{libc}-standalone.tar.zst`: Binary only (‚ö†Ô∏è NOT RECOMMENDED - requires system runc ‚â•1.1.11 + latest conmon)
            - `buildah-{version}-linux-{arch}-{libc}-full.tar.zst`: Complete build stack with fuse-overlayfs for rootless overlay mounts

          **COMPATIBILITY WARNINGS**
            - `standalone` requires compatible system packages (most Ubuntu versions have outdated runc/conmon)
            - `default` and `full` include all required runtimes - work on any Linux distribution

          **INSTALLATION**

          **Option A: Standalone variant (single binary)**
          ```bash
          # Download and extract (static variant recommended)
          curl -fsSL -O https://github.com/${{ github.repository }}/releases/download/buildah-${{ needs.build.outputs.version }}/buildah-${{ needs.build.outputs.version }}-linux-amd64-static-standalone.tar.zst
          tar -xf buildah-${{ needs.build.outputs.version }}-linux-amd64-static-standalone.tar.zst
          cd buildah-${{ needs.build.outputs.version }}

          # Run directly or copy to your preferred location
          ./buildah --version
          cp buildah ~/.local/bin/  # or /usr/local/bin with sudo
          ```

          **Option B: Default/Full variant (recommended)**
          ```bash
          # Download tarball for your architecture (static variant recommended)
          curl -fsSL -O https://github.com/${{ github.repository }}/releases/download/buildah-${{ needs.build.outputs.version }}/buildah-${{ needs.build.outputs.version }}-linux-amd64-static.tar.zst

          # Extract
          tar -xf buildah-${{ needs.build.outputs.version }}-linux-amd64-static.tar.zst
          cd buildah-${{ needs.build.outputs.version }}

          # Install system-wide
          sudo cp -r usr/* /usr/
          sudo cp -r etc/* /etc/

          # Or use from current directory
          export PATH=$PWD/usr/local/bin:$PATH
          buildah --version
          ```

          **For glibc variant** (requires glibc 2.34+):
          Replace `-static.tar.zst` with `-glibc.tar.zst` in the download URL.

          **VERIFICATION**

          All tarballs include SHA256 checksums and cosign signatures (keyless OIDC).

          Verify checksum:
          ```bash
          sha256sum -c checksums.txt --ignore-missing
          ```

          Verify cosign signature (example for default static variant):
          ```bash
          # Replace VERSION with actual version (e.g., v1.38.0)
          cosign verify-blob \
            --bundle=buildah-VERSION-linux-amd64-static.tar.zst.bundle \
            --certificate-identity-regexp='https://github.com/.*' \
            --certificate-oidc-issuer='https://token.actions.githubusercontent.com' \
            buildah-VERSION-linux-amd64-static.tar.zst
          ```

          **BUILD DETAILS**
          - Built inside docker.io/ubuntu:latest container using podman
          - Compiler: Clang (static: musl target, glibc: default target) + mimalloc allocator
          - Build tools:
            - Clang: ${CLANG_VERSION}
            - Go: ${GO_VERSION}
            - Rust: ${RUST_VERSION}
            - CMake: ${CMAKE_VERSION}
            - Ninja: ${NINJA_VERSION}
            - Python: ${PYTHON_VERSION} (via uv)
            - glib: ${GLIB_VERSION} (only for default/full variants)
          - Workflow ${{ github.workflow }}
          - Run ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          NOTES

          # Create or update release
          if gh release view "$TAG" &>/dev/null; then
            echo "Release $TAG already exists, uploading additional assets..."
            gh release upload "$TAG" release/* --clobber
          else
            echo "Creating new release $TAG..."
            gh release create "$TAG" \
              --title "Buildah ${VERSION}" \
              --notes-file /tmp/release-notes.md \
              release/*
          fi

      - name: Release Summary
        env:
          VERSION: ${{ needs.build.outputs.version }}
        run: |
          echo "### üöÄ Release Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: buildah-${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "**Artifacts**:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          ls -lh release/ >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Download**: https://github.com/${{ github.repository }}/releases/tag/buildah-${VERSION}" >> $GITHUB_STEP_SUMMARY
